{"mappings":"2UAAA,IAAAA,EAAAC,EAAA,SACOC,eAAeC,EAAcC,EAAQC,GAAU,GAClD,MAAMC,WAAEA,SAAqBC,QAAAC,QAAAP,EAAA,gBACvBG,EAAOK,SAAST,EAAAU,WAAY,IAAIJ,EAAcD,E,2GCHxD,IAAAM,EAAAV,EAAA,S,aAEO,MAAMW,EAAa,CAAC,OAAQ,YAAa,OAAQ,kBACjD,MAAMC,EACTC,KAAKC,IACD,EAAAC,EAAAC,UAASF,E,CAEbb,WAAWgB,GACP,MAAMC,EAAUD,EAAUE,cAC1B,GAAIR,EAAWS,MAAMC,IAAM,EAAAX,EAAAY,WAAUD,EAAGH,EAAQK,UAAUC,MAAMC,QAAQ,CACpE,MAAMC,EAAef,EAChBgB,KAAKN,GAAMH,EAAQK,UAAUC,MAAMN,QAAQG,KAC3CD,MAAMC,KAAQA,IAAIO,EAAW,IAClC,EAAAlB,EAAAmB,2BAA0BH,GAAeF,IACrCI,EAASE,MAAK,EAAApB,EAAAqB,UAASP,EAAMQ,KAAMR,EAAMS,QAAQ,UAE/C3B,QAAQ4B,IAAIN,E,EAG1BO,aAAalB,EAAWmB,GACpB,IAAKA,EAASZ,QAAUb,EAAW0B,SAASD,EAASZ,OACjD,OAEJ,MAAMc,EAAYF,EAASG,UAC3B,QAAkBC,IAAdF,EACA,OAEJ,MAAMG,EAAWH,EAAUI,WACVF,IAAbC,IAGJL,EAASO,MAAO,EAAAjC,EAAAkC,0BAAyBH,EAAUL,EAASS,iB,wEC/BpE,IAAAnC,EAAAV,EAAA,SAEO,SAAS8C,EAAShC,GACrB,MAAMiC,QAAEA,EAAOX,SAAEA,EAAQY,OAAEA,EAAMC,QAAEA,GAAYnC,EAAMwB,EAAYF,EAASG,UAC1E,IAAKD,EACD,OAEJ,MAAMG,EAAWH,EAAUI,MAC3B,QAAiBF,IAAbC,EACA,YAEkBD,IAAlBJ,EAASO,OACTP,EAASO,MAAO,EAAAjC,EAAAkC,0BAAyBH,EAAUL,EAASS,kBAEhE,MAAMF,EAAOP,EAASO,KAAMO,EAAQZ,EAAUY,OAAS,GAAIjB,EAASK,EAAUL,QAAU,MAAOkB,EAbpF,EAa2FC,KAAKC,MAAML,GAAkBhB,EAAOM,EAAUN,MAAQ,UAAWsB,EAAOlB,EAASmB,UACjLC,EAAQb,GAAMc,MAAM,MAC1B,GAAKD,EAAL,CAGAT,EAAQf,KAAO,GAAGkB,KAASjB,KAAUkB,QAAWnB,KAChDe,EAAQW,YAAcT,EACtB,IAAK,IAAIU,EAAI,EAAGA,EAAIH,EAAMI,OAAQD,IAC9BE,EAASd,EAASS,EAAMG,GAAIX,EAAQC,EAASU,EAAGL,GAEpDP,EAAQW,YAAc,CAPlB,C,CASR,SAASG,EAASd,EAASe,EAAMd,EAAQC,EAASc,EAAOT,GACrD,MAA6CU,EAAM,CAC/CC,IADYH,EAAKF,OAASZ,EA1BT,IA4BjBkB,EA5BiB,GA4BdlB,GACJmB,EA7BQ,EA6BGnB,EACVM,EACAP,EAAQqB,SAASN,EAAME,EAAIC,EAAGD,EAAIE,EAAIC,EAAWJ,GAGjDhB,EAAQsB,WAAWP,EAAME,EAAIC,EAAGD,EAAIE,EAAIC,EAAWJ,E","sources":["node_modules/@tsparticles/shape-text/browser/index.js","node_modules/@tsparticles/shape-text/browser/TextDrawer.js","node_modules/@tsparticles/shape-text/browser/Utils.js"],"sourcesContent":["import { validTypes } from \"./TextDrawer.js\";\nexport async function loadTextShape(engine, refresh = true) {\n    const { TextDrawer } = await import(\"./TextDrawer.js\");\n    await engine.addShape(validTypes, new TextDrawer(), refresh);\n}\n","import { executeOnSingleOrMultiple, isInArray, itemFromSingleOrMultiple, loadFont, } from \"@tsparticles/engine\";\nimport { drawText } from \"./Utils.js\";\nexport const validTypes = [\"text\", \"character\", \"char\", \"multiline-text\"];\nexport class TextDrawer {\n    draw(data) {\n        drawText(data);\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (validTypes.find((t) => isInArray(t, options.particles.shape.type))) {\n            const shapeOptions = validTypes\n                .map((t) => options.particles.shape.options[t])\n                .find((t) => !!t), promises = [];\n            executeOnSingleOrMultiple(shapeOptions, (shape) => {\n                promises.push(loadFont(shape.font, shape.weight));\n            });\n            await Promise.all(promises);\n        }\n    }\n    particleInit(container, particle) {\n        if (!particle.shape || !validTypes.includes(particle.shape)) {\n            return;\n        }\n        const character = particle.shapeData;\n        if (character === undefined) {\n            return;\n        }\n        const textData = character.value;\n        if (textData === undefined) {\n            return;\n        }\n        particle.text = itemFromSingleOrMultiple(textData, particle.randomIndexData);\n    }\n}\n","import { itemFromSingleOrMultiple } from \"@tsparticles/engine\";\nconst double = 2, half = 0.5;\nexport function drawText(data) {\n    const { context, particle, radius, opacity } = data, character = particle.shapeData;\n    if (!character) {\n        return;\n    }\n    const textData = character.value;\n    if (textData === undefined) {\n        return;\n    }\n    if (particle.text === undefined) {\n        particle.text = itemFromSingleOrMultiple(textData, particle.randomIndexData);\n    }\n    const text = particle.text, style = character.style ?? \"\", weight = character.weight ?? \"400\", size = Math.round(radius) * double, font = character.font ?? \"Verdana\", fill = particle.shapeFill;\n    const lines = text?.split(\"\\n\");\n    if (!lines) {\n        return;\n    }\n    context.font = `${style} ${weight} ${size}px \"${font}\"`;\n    context.globalAlpha = opacity;\n    for (let i = 0; i < lines.length; i++) {\n        drawLine(context, lines[i], radius, opacity, i, fill);\n    }\n    context.globalAlpha = 1;\n}\nfunction drawLine(context, line, radius, opacity, index, fill) {\n    const offsetX = line.length * radius * half, pos = {\n        x: -offsetX,\n        y: radius * half,\n    }, diameter = radius * double;\n    if (fill) {\n        context.fillText(line, pos.x, pos.y + diameter * index);\n    }\n    else {\n        context.strokeText(line, pos.x, pos.y + diameter * index);\n    }\n}\n"],"names":["$1ccLU","parcelRequire","async","$47d8e9a86c79938e$export$da06b6ff4c270300","engine","refresh","TextDrawer","Promise","resolve","addShape","validTypes","$i0lBz","$0df0d1a2e2269f2e$export$7479ced0de99242c","$0df0d1a2e2269f2e$export$a007af5794c15990","draw","data","$gOSUI","drawText","container","options","actualOptions","find","t","isInArray","particles","shape","type","shapeOptions","map","promises","executeOnSingleOrMultiple","push","loadFont","font","weight","all","particleInit","particle","includes","character","shapeData","undefined","textData","value","text","itemFromSingleOrMultiple","randomIndexData","$c3ebe99025211821$export$b11bd9a0808bdc9","context","radius","opacity","style","size","Math","round","fill","shapeFill","lines","split","globalAlpha","i","length","$c3ebe99025211821$var$drawLine","line","index","pos","x","y","diameter","fillText","strokeText"],"version":3,"file":"browser.bb20384b.js.map"}