{"mappings":"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","sources":["node_modules/@tsparticles/interaction-particles-links/browser/Linker.js","node_modules/@tsparticles/interaction-particles-links/browser/CircleWarp.js"],"sourcesContent":["import { Circle, ParticlesInteractorBase, getDistances, getLinkRandomColor, } from \"@tsparticles/engine\";\nimport { CircleWarp } from \"./CircleWarp.js\";\nimport { Links } from \"./Options/Classes/Links.js\";\nconst squarePower = 2, opacityOffset = 1, origin = {\n    x: 0,\n    y: 0,\n}, minDistance = 0;\nfunction getLinkDistance(pos1, pos2, optDistance, canvasSize, warp) {\n    const { dx, dy, distance } = getDistances(pos1, pos2);\n    if (!warp || distance <= optDistance) {\n        return distance;\n    }\n    const absDiffs = {\n        x: Math.abs(dx),\n        y: Math.abs(dy),\n    }, warpDistances = {\n        x: Math.min(absDiffs.x, canvasSize.width - absDiffs.x),\n        y: Math.min(absDiffs.y, canvasSize.height - absDiffs.y),\n    };\n    return Math.sqrt(warpDistances.x ** squarePower + warpDistances.y ** squarePower);\n}\nexport class Linker extends ParticlesInteractorBase {\n    constructor(container) {\n        super(container);\n        this._setColor = (p1) => {\n            if (!p1.options.links) {\n                return;\n            }\n            const container = this.linkContainer, linksOptions = p1.options.links;\n            let linkColor = linksOptions.id === undefined\n                ? container.particles.linksColor\n                : container.particles.linksColors.get(linksOptions.id);\n            if (linkColor) {\n                return;\n            }\n            const optColor = linksOptions.color;\n            linkColor = getLinkRandomColor(optColor, linksOptions.blink, linksOptions.consent);\n            if (linksOptions.id === undefined) {\n                container.particles.linksColor = linkColor;\n            }\n            else {\n                container.particles.linksColors.set(linksOptions.id, linkColor);\n            }\n        };\n        this.linkContainer = container;\n    }\n    clear() {\n    }\n    init() {\n        this.linkContainer.particles.linksColor = undefined;\n        this.linkContainer.particles.linksColors = new Map();\n    }\n    interact(p1) {\n        if (!p1.options.links) {\n            return;\n        }\n        p1.links = [];\n        const pos1 = p1.getPosition(), container = this.container, canvasSize = container.canvas.size;\n        if (pos1.x < origin.x || pos1.y < origin.y || pos1.x > canvasSize.width || pos1.y > canvasSize.height) {\n            return;\n        }\n        const linkOpt1 = p1.options.links, optOpacity = linkOpt1.opacity, optDistance = p1.retina.linksDistance ?? minDistance, warp = linkOpt1.warp;\n        let range;\n        if (warp) {\n            range = new CircleWarp(pos1.x, pos1.y, optDistance, canvasSize);\n        }\n        else {\n            range = new Circle(pos1.x, pos1.y, optDistance);\n        }\n        const query = container.particles.quadTree.query(range);\n        for (const p2 of query) {\n            const linkOpt2 = p2.options.links;\n            if (p1 === p2 ||\n                !linkOpt2?.enable ||\n                linkOpt1.id !== linkOpt2.id ||\n                p2.spawning ||\n                p2.destroyed ||\n                !p2.links ||\n                p1.links.some((t) => t.destination === p2) ||\n                p2.links.some((t) => t.destination === p1)) {\n                continue;\n            }\n            const pos2 = p2.getPosition();\n            if (pos2.x < origin.x || pos2.y < origin.y || pos2.x > canvasSize.width || pos2.y > canvasSize.height) {\n                continue;\n            }\n            const distance = getLinkDistance(pos1, pos2, optDistance, canvasSize, warp && linkOpt2.warp);\n            if (distance > optDistance) {\n                continue;\n            }\n            const opacityLine = (opacityOffset - distance / optDistance) * optOpacity;\n            this._setColor(p1);\n            p1.links.push({\n                destination: p2,\n                opacity: opacityLine,\n            });\n        }\n    }\n    isEnabled(particle) {\n        return !!particle.options.links?.enable;\n    }\n    loadParticlesOptions(options, ...sources) {\n        if (!options.links) {\n            options.links = new Links();\n        }\n        for (const source of sources) {\n            options.links.load(source?.links);\n        }\n    }\n    reset() {\n    }\n}\n","import { Circle, Rectangle } from \"@tsparticles/engine\";\nconst double = 2;\nexport class CircleWarp extends Circle {\n    constructor(x, y, radius, canvasSize) {\n        super(x, y, radius);\n        this.canvasSize = canvasSize;\n        this.canvasSize = { ...canvasSize };\n    }\n    contains(point) {\n        const { width, height } = this.canvasSize, { x, y } = point;\n        return (super.contains(point) ||\n            super.contains({ x: x - width, y }) ||\n            super.contains({ x: x - width, y: y - height }) ||\n            super.contains({ x, y: y - height }));\n    }\n    intersects(range) {\n        if (super.intersects(range)) {\n            return true;\n        }\n        const rect = range, circle = range, newPos = {\n            x: range.position.x - this.canvasSize.width,\n            y: range.position.y - this.canvasSize.height,\n        };\n        if (circle.radius !== undefined) {\n            const biggerCircle = new Circle(newPos.x, newPos.y, circle.radius * double);\n            return super.intersects(biggerCircle);\n        }\n        else if (rect.size !== undefined) {\n            const rectSW = new Rectangle(newPos.x, newPos.y, rect.size.width * double, rect.size.height * double);\n            return super.intersects(rectSW);\n        }\n        return false;\n    }\n}\n"],"names":["$i0lBz","parcelRequire","$4346a3f946ba01df$var$origin","$4346a3f946ba01df$var$getLinkDistance","pos1","pos2","optDistance","canvasSize","warp","dx","dy","distance","getDistances","absDiffs","x","Math","abs","y","warpDistances","min","width","height","sqrt","$4346a3f946ba01df$export$5bd94e9ac300debe","ParticlesInteractorBase","constructor","container","super","this","_setColor","p1","options","links","linkContainer","linksOptions","linkColor","undefined","id","particles","linksColor","linksColors","get","optColor","color","getLinkRandomColor","blink","consent","set","clear","init","Map","interact","getPosition","canvas","size","linkOpt1","optOpacity","opacity","retina","linksDistance","range","$5cJgk","CircleWarp","Circle","query","quadTree","p2","linkOpt2","enable","spawning","destroyed","some","t","destination","opacityLine","push","isEnabled","particle","loadParticlesOptions","sources","$dWwXT","Links","source","load","reset","$3ca12ee8ea1d3864$export$63eeb78c14ab922","radius","contains","point","intersects","rect","circle","newPos","position","biggerCircle","rectSW","Rectangle"],"version":3,"file":"Linker.871b2509.js.map"}