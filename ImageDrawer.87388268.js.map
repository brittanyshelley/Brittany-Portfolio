{"mappings":"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","sources":["node_modules/@tsparticles/shape-image/browser/ImageDrawer.js"],"sourcesContent":["import { errorPrefix } from \"@tsparticles/engine\";\nimport { replaceImageColor } from \"./Utils.js\";\nimport { drawGif } from \"./GifUtils/Utils.js\";\nconst double = 2, defaultAlpha = 1, sides = 12, defaultRatio = 1;\nexport class ImageDrawer {\n    constructor(engine) {\n        this.loadImageShape = async (imageShape) => {\n            if (!this._engine.loadImage) {\n                throw new Error(`${errorPrefix} image shape not initialized`);\n            }\n            await this._engine.loadImage({\n                gif: imageShape.gif,\n                name: imageShape.name,\n                replaceColor: imageShape.replaceColor ?? false,\n                src: imageShape.src,\n            });\n        };\n        this._engine = engine;\n    }\n    addImage(image) {\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        this._engine.images.push(image);\n    }\n    draw(data) {\n        const { context, radius, particle, opacity } = data, image = particle.image, element = image?.element;\n        if (!image) {\n            return;\n        }\n        context.globalAlpha = opacity;\n        if (image.gif && image.gifData) {\n            drawGif(data);\n        }\n        else if (element) {\n            const ratio = image.ratio, pos = {\n                x: -radius,\n                y: -radius,\n            }, diameter = radius * double;\n            context.drawImage(element, pos.x, pos.y, diameter, diameter / ratio);\n        }\n        context.globalAlpha = defaultAlpha;\n    }\n    getSidesCount() {\n        return sides;\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (!options.preload || !this._engine.loadImage) {\n            return;\n        }\n        for (const imageData of options.preload) {\n            await this._engine.loadImage(imageData);\n        }\n    }\n    loadShape(particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const imageData = particle.shapeData;\n        if (!imageData) {\n            return;\n        }\n        const image = this._engine.images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            void this.loadImageShape(imageData).then(() => {\n                this.loadShape(particle);\n            });\n        }\n    }\n    particleInit(container, particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const images = this._engine.images, imageData = particle.shapeData;\n        if (!imageData) {\n            return;\n        }\n        const color = particle.getFillColor(), image = images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            return;\n        }\n        const replaceColor = imageData.replaceColor ?? image.replaceColor;\n        if (image.loading) {\n            setTimeout(() => {\n                this.particleInit(container, particle);\n            });\n            return;\n        }\n        void (async () => {\n            let imageRes;\n            if (image.svgData && color) {\n                imageRes = await replaceImageColor(image, imageData, color, particle);\n            }\n            else {\n                imageRes = {\n                    color,\n                    data: image,\n                    element: image.element,\n                    gif: image.gif,\n                    gifData: image.gifData,\n                    gifLoopCount: image.gifLoopCount,\n                    loaded: true,\n                    ratio: imageData.width && imageData.height\n                        ? imageData.width / imageData.height\n                        : image.ratio ?? defaultRatio,\n                    replaceColor: replaceColor,\n                    source: imageData.src,\n                };\n            }\n            if (!imageRes.ratio) {\n                imageRes.ratio = 1;\n            }\n            const fill = imageData.fill ?? particle.shapeFill, close = imageData.close ?? particle.shapeClose, imageShape = {\n                image: imageRes,\n                fill,\n                close,\n            };\n            particle.image = imageShape.image;\n            particle.shapeFill = imageShape.fill;\n            particle.shapeClose = imageShape.close;\n        })();\n    }\n}\n"],"names":["$i0lBz","parcelRequire","$0ddcbab58f35ce16$export$b1e5f9a9161ef3b1","constructor","engine","this","loadImageShape","async","imageShape","_engine","loadImage","Error","errorPrefix","gif","name","replaceColor","src","addImage","image","images","push","draw","data","context","radius","particle","opacity","element","globalAlpha","gifData","$bbgOK","drawGif","ratio","pos","x","y","diameter","drawImage","getSidesCount","container","options","actualOptions","preload","imageData","loadShape","shape","shapeData","find","t","source","then","particleInit","color","getFillColor","loading","setTimeout","imageRes","svgData","$asyfB","replaceImageColor","gifLoopCount","loaded","width","height","fill","shapeFill","close","shapeClose"],"version":3,"file":"ImageDrawer.87388268.js.map"}