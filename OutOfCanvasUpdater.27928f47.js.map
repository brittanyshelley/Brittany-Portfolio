{"mappings":"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","sources":["node_modules/@tsparticles/updater-out-modes/browser/OutOfCanvasUpdater.js","node_modules/@tsparticles/updater-out-modes/browser/BounceOutMode.js","node_modules/@tsparticles/updater-out-modes/browser/Utils.js","node_modules/@tsparticles/updater-out-modes/browser/DestroyOutMode.js","node_modules/@tsparticles/updater-out-modes/browser/NoneOutMode.js","node_modules/@tsparticles/updater-out-modes/browser/OutOutMode.js"],"sourcesContent":["import { BounceOutMode } from \"./BounceOutMode.js\";\nimport { DestroyOutMode } from \"./DestroyOutMode.js\";\nimport { NoneOutMode } from \"./NoneOutMode.js\";\nimport { OutOutMode } from \"./OutOutMode.js\";\nconst checkOutMode = (outModes, outMode) => {\n    return (outModes.default === outMode ||\n        outModes.bottom === outMode ||\n        outModes.left === outMode ||\n        outModes.right === outMode ||\n        outModes.top === outMode);\n};\nexport class OutOfCanvasUpdater {\n    constructor(container) {\n        this._updateOutMode = (particle, delta, outMode, direction) => {\n            for (const updater of this.updaters) {\n                updater.update(particle, direction, delta, outMode);\n            }\n        };\n        this.container = container;\n        this.updaters = [];\n    }\n    init(particle) {\n        this.updaters = [];\n        const outModes = particle.options.move.outModes;\n        if (checkOutMode(outModes, \"bounce\")) {\n            this.updaters.push(new BounceOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"out\")) {\n            this.updaters.push(new OutOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"destroy\")) {\n            this.updaters.push(new DestroyOutMode(this.container));\n        }\n        else if (checkOutMode(outModes, \"none\")) {\n            this.updaters.push(new NoneOutMode(this.container));\n        }\n    }\n    isEnabled(particle) {\n        return !particle.destroyed && !particle.spawning;\n    }\n    update(particle, delta) {\n        const outModes = particle.options.move.outModes;\n        this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, \"bottom\");\n        this._updateOutMode(particle, delta, outModes.left ?? outModes.default, \"left\");\n        this._updateOutMode(particle, delta, outModes.right ?? outModes.default, \"right\");\n        this._updateOutMode(particle, delta, outModes.top ?? outModes.default, \"top\");\n    }\n}\n","import { calculateBounds, } from \"@tsparticles/engine\";\nimport { bounceHorizontal, bounceVertical } from \"./Utils.js\";\nexport class BounceOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\n            \"bounce\",\n            \"split\",\n        ];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        let handled = false;\n        for (const [, plugin] of container.plugins) {\n            if (plugin.particleBounce !== undefined) {\n                handled = plugin.particleBounce(particle, delta, direction);\n            }\n            if (handled) {\n                break;\n            }\n        }\n        if (handled) {\n            return;\n        }\n        const pos = particle.getPosition(), offset = particle.offset, size = particle.getRadius(), bounds = calculateBounds(pos, size), canvasSize = container.canvas.size;\n        bounceHorizontal({ particle, outMode, direction, bounds, canvasSize, offset, size });\n        bounceVertical({ particle, outMode, direction, bounds, canvasSize, offset, size });\n    }\n}\n","import { getRangeValue } from \"@tsparticles/engine\";\nconst minVelocity = 0, boundsMin = 0;\nexport function bounceHorizontal(data) {\n    if ((data.outMode !== \"bounce\" && data.outMode !== \"split\") ||\n        (data.direction !== \"left\" && data.direction !== \"right\")) {\n        return;\n    }\n    if (data.bounds.right < boundsMin && data.direction === \"left\") {\n        data.particle.position.x = data.size + data.offset.x;\n    }\n    else if (data.bounds.left > data.canvasSize.width && data.direction === \"right\") {\n        data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;\n    }\n    const velocity = data.particle.velocity.x;\n    let bounced = false;\n    if ((data.direction === \"right\" &&\n        data.bounds.right >= data.canvasSize.width &&\n        velocity > minVelocity) ||\n        (data.direction === \"left\" && data.bounds.left <= boundsMin && velocity < minVelocity)) {\n        const newVelocity = getRangeValue(data.particle.options.bounce.horizontal.value);\n        data.particle.velocity.x *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.x + data.size;\n    if (data.bounds.right >= data.canvasSize.width && data.direction === \"right\") {\n        data.particle.position.x = data.canvasSize.width - minPos;\n    }\n    else if (data.bounds.left <= boundsMin && data.direction === \"left\") {\n        data.particle.position.x = minPos;\n    }\n    if (data.outMode === \"split\") {\n        data.particle.destroy();\n    }\n}\nexport function bounceVertical(data) {\n    if ((data.outMode !== \"bounce\" && data.outMode !== \"split\") ||\n        (data.direction !== \"bottom\" && data.direction !== \"top\")) {\n        return;\n    }\n    if (data.bounds.bottom < boundsMin && data.direction === \"top\") {\n        data.particle.position.y = data.size + data.offset.y;\n    }\n    else if (data.bounds.top > data.canvasSize.height && data.direction === \"bottom\") {\n        data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;\n    }\n    const velocity = data.particle.velocity.y;\n    let bounced = false;\n    if ((data.direction === \"bottom\" &&\n        data.bounds.bottom >= data.canvasSize.height &&\n        velocity > minVelocity) ||\n        (data.direction === \"top\" && data.bounds.top <= boundsMin && velocity < minVelocity)) {\n        const newVelocity = getRangeValue(data.particle.options.bounce.vertical.value);\n        data.particle.velocity.y *= -newVelocity;\n        bounced = true;\n    }\n    if (!bounced) {\n        return;\n    }\n    const minPos = data.offset.y + data.size;\n    if (data.bounds.bottom >= data.canvasSize.height && data.direction === \"bottom\") {\n        data.particle.position.y = data.canvasSize.height - minPos;\n    }\n    else if (data.bounds.top <= boundsMin && data.direction === \"top\") {\n        data.particle.position.y = minPos;\n    }\n    if (data.outMode === \"split\") {\n        data.particle.destroy();\n    }\n}\n","import { Vector, getDistances, isPointInside, } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class DestroyOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"destroy\"];\n    }\n    update(particle, direction, _delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"normal\":\n            case \"outside\":\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                break;\n            case \"inside\": {\n                const { dx, dy } = getDistances(particle.position, particle.moveCenter), { x: vx, y: vy } = particle.velocity;\n                if ((vx < minVelocity && dx > particle.moveCenter.radius) ||\n                    (vy < minVelocity && dy > particle.moveCenter.radius) ||\n                    (vx >= minVelocity && dx < -particle.moveCenter.radius) ||\n                    (vy >= minVelocity && dy < -particle.moveCenter.radius)) {\n                    return;\n                }\n                break;\n            }\n        }\n        container.particles.remove(particle, undefined, true);\n    }\n}\n","import { Vector, isPointInside, } from \"@tsparticles/engine\";\nconst minVelocity = 0;\nexport class NoneOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"none\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        if ((particle.options.move.distance.horizontal &&\n            (direction === \"left\" || direction === \"right\")) ??\n            (particle.options.move.distance.vertical &&\n                (direction === \"top\" || direction === \"bottom\"))) {\n            return;\n        }\n        const gravityOptions = particle.options.move.gravity, container = this.container, canvasSize = container.canvas.size, pRadius = particle.getRadius();\n        if (!gravityOptions.enable) {\n            if ((particle.velocity.y > minVelocity && particle.position.y <= canvasSize.height + pRadius) ||\n                (particle.velocity.y < minVelocity && particle.position.y >= -pRadius) ||\n                (particle.velocity.x > minVelocity && particle.position.x <= canvasSize.width + pRadius) ||\n                (particle.velocity.x < minVelocity && particle.position.x >= -pRadius)) {\n                return;\n            }\n            if (!isPointInside(particle.position, container.canvas.size, Vector.origin, pRadius, direction)) {\n                container.particles.remove(particle);\n            }\n        }\n        else {\n            const position = particle.position;\n            if ((!gravityOptions.inverse &&\n                position.y > canvasSize.height + pRadius &&\n                direction === \"bottom\") ||\n                (gravityOptions.inverse && position.y < -pRadius && direction === \"top\")) {\n                container.particles.remove(particle);\n            }\n        }\n    }\n}\n","import { Vector, calculateBounds, getDistances, getRandom, isPointInside, randomInRange, } from \"@tsparticles/engine\";\nconst minVelocity = 0, minDistance = 0;\nexport class OutOutMode {\n    constructor(container) {\n        this.container = container;\n        this.modes = [\"out\"];\n    }\n    update(particle, direction, delta, outMode) {\n        if (!this.modes.includes(outMode)) {\n            return;\n        }\n        const container = this.container;\n        switch (particle.outType) {\n            case \"inside\": {\n                const { x: vx, y: vy } = particle.velocity;\n                const circVec = Vector.origin;\n                circVec.length = particle.moveCenter.radius;\n                circVec.angle = particle.velocity.angle + Math.PI;\n                circVec.addTo(Vector.create(particle.moveCenter));\n                const { dx, dy } = getDistances(particle.position, circVec);\n                if ((vx <= minVelocity && dx >= minDistance) ||\n                    (vy <= minVelocity && dy >= minDistance) ||\n                    (vx >= minVelocity && dx <= minDistance) ||\n                    (vy >= minVelocity && dy <= minDistance)) {\n                    return;\n                }\n                particle.position.x = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.width,\n                }));\n                particle.position.y = Math.floor(randomInRange({\n                    min: 0,\n                    max: container.canvas.size.height,\n                }));\n                const { dx: newDx, dy: newDy } = getDistances(particle.position, particle.moveCenter);\n                particle.direction = Math.atan2(-newDy, -newDx);\n                particle.velocity.angle = particle.direction;\n                break;\n            }\n            default: {\n                if (isPointInside(particle.position, container.canvas.size, Vector.origin, particle.getRadius(), direction)) {\n                    return;\n                }\n                switch (particle.outType) {\n                    case \"outside\": {\n                        particle.position.x =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.x;\n                        particle.position.y =\n                            Math.floor(randomInRange({\n                                min: -particle.moveCenter.radius,\n                                max: particle.moveCenter.radius,\n                            })) + particle.moveCenter.y;\n                        const { dx, dy } = getDistances(particle.position, particle.moveCenter);\n                        if (particle.moveCenter.radius) {\n                            particle.direction = Math.atan2(dy, dx);\n                            particle.velocity.angle = particle.direction;\n                        }\n                        break;\n                    }\n                    case \"normal\": {\n                        const warp = particle.options.move.warp, canvasSize = container.canvas.size, newPos = {\n                            bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                            left: -particle.getRadius() - particle.offset.x,\n                            right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                            top: -particle.getRadius() - particle.offset.y,\n                        }, sizeValue = particle.getRadius(), nextBounds = calculateBounds(particle.position, sizeValue);\n                        if (direction === \"right\" &&\n                            nextBounds.left > canvasSize.width + particle.offset.x) {\n                            particle.position.x = newPos.left;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                            particle.position.x = newPos.right;\n                            particle.initialPosition.x = particle.position.x;\n                            if (!warp) {\n                                particle.position.y = getRandom() * canvasSize.height;\n                                particle.initialPosition.y = particle.position.y;\n                            }\n                        }\n                        if (direction === \"bottom\" &&\n                            nextBounds.top > canvasSize.height + particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.top;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                            if (!warp) {\n                                particle.position.x = getRandom() * canvasSize.width;\n                                particle.initialPosition.x = particle.position.x;\n                            }\n                            particle.position.y = newPos.bottom;\n                            particle.initialPosition.y = particle.position.y;\n                        }\n                        break;\n                    }\n                }\n                break;\n            }\n        }\n    }\n}\n"],"names":["$4rzyQ","parcelRequire","$d45484ef94ad4675$var$checkOutMode","outModes","outMode","default","bottom","left","right","top","$d45484ef94ad4675$export$cb0990f1117a9f95","constructor","container","this","_updateOutMode","particle","delta","direction","updater","updaters","update","init","options","move","push","BounceOutMode","$dKanF","OutOutMode","$jYVYT","DestroyOutMode","$eVtEO","NoneOutMode","isEnabled","destroyed","spawning","$i0lBz","$33c544b1f32b5a68$export$7a10ae135b551126","modes","includes","handled","plugin","plugins","undefined","particleBounce","pos","getPosition","offset","size","getRadius","bounds","calculateBounds","canvasSize","canvas","$hIN5r","bounceHorizontal","bounceVertical","$ce6c9f54fb93f1af$export$1def114a7da042cf","data","position","x","width","velocity","bounced","newVelocity","getRangeValue","bounce","horizontal","value","minPos","destroy","$ce6c9f54fb93f1af$export$46000c44e0211bc6","y","height","vertical","$e8c098c4cb02006d$export$4c86fe322e2200a","_delta","outType","isPointInside","Vector","origin","dx","dy","getDistances","moveCenter","vx","vy","radius","particles","remove","$addd64e4de9f78e0$export$a026dc73727d2f19","distance","gravityOptions","gravity","pRadius","enable","inverse","$a0179fa907265dbd$export$7300b77892783c0e","circVec","length","angle","Math","PI","addTo","create","floor","randomInRange","min","max","newDx","newDy","atan2","dx1","dy1","warp","newPos","sizeValue","nextBounds","initialPosition","getRandom"],"version":3,"file":"OutOfCanvasUpdater.27928f47.js.map"}